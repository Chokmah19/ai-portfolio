## Problem_4_AddBinary

## 🎯題目描述

- 輸入：兩個只包含 0 & 1的**二進位字串**
- 輸出：兩者相加後的結果，形式仍為「二進位字串」

## 🧠解題思路

- 解法：由右往左「逐位相加」，處理進位（carry），再組成最後答案字串

🧱 基本邏輯：
1. 從兩個字串的最尾端（也就是最低位）開始加
2. 每一回合：取出目前位數 + 進位（carry）後加總
3. 把加總的結果轉為字元加到結果字串中（只取 0 或 1）
4. 更新進位（sum >= 2 時才會有進位）
5. 若兩個字串都處理完，但還有進位，要額外補上

🤔 過程中我提出了幾個問題來幫助自己理解：

❓ sum % 2 是什麼意思？
用來決定這一位數字應該是 0 還是 1
因為二進位只能放 0 或 1，所以只能留下總和除以 2 的「餘數」
例如：1 + 1 + 1 = 3，3 % 2 = 1 → 這一位放 1

❓ sum // 2 是什麼意思？
計算這一回合運算後要不要「進位」
當總和超過或等於 2，就會需要進位
例如：1 + 1 = 2，2 // 2 = 1 → 有一個進位要留到下一位使用

❓ 為什麼指標初始化是 i = len(a) - 1？
len(a) 是字串的總長度，但 index 是從 0 開始
len(a) - 1 才是最後一位數（最右邊）的索引
我們從尾端開始加，才能模擬真實的位元加法邏輯（像國小加法從個位數開始）

❓ 為什麼要 while i >= 0 or j >= 0 or carry？
i >= 0: a 還沒加完
j >= 0: b 還沒加完
carry: 雖然兩數都加完，但最後一位仍有進位要補上

👉 **如果少了 or carry，那 a = "1", b = "1" 這種會少算一個位元（應該得到 "10"，卻只會得到 "0"）**

❓ 為什麼要反轉結果？
因為我們是從右往左處理的，結果的順序也是反的

要用 reversed(result) 搭配 ''.join(...) 把結果反過來組合成字串

## 🗒️心得
   重新複習了二進位加法，了解了為甚麼不能直接轉成十進位處理，此題目標是練習「字串處理 + 二進位邏輯」的實作能力。
   然後學會了「從右往左處理」、「進位邏輯」、「補 0 避免 index 越界」這些實務技巧。
   另外，本題重點為 or carry、反轉字串，以及下面所述的關鍵公式。
   
## ⚡關鍵公式

- sum % 2
    - 這一位應該放什麼數字
    - 「總和除以 2 的餘數」
- sum // 2
    - 新的進位 carry 值
    - 「總和除以 2 的商」

   
